<?php
/**
 * Created by PhpStorm.
 * User: goku
 * Date: 19/08/2014
 * Time: 08:54
 */

namespace Demo\Model\Dao;

use Demo\Model\Builder\DefaultEntityBuilder;
use Demo\Model\Builder\IDefaultEntityBuilder;
use Demo\Model\Entity\RankNick;
use Doctrine\ORM\Id\AssignedGenerator;
use Kdyby\Doctrine\DuplicateEntryException;
use Kdyby\Doctrine\EntityDao;
use Kdyby\Doctrine\Mapping\ClassMetadata;
use Nette\Neon\Exception;

/**
 * Class RankNickDao
 * @package Demo\Model\Dao
 */
class RankNickDao implements IRankNickDao
{

    /** @var int */
    private $bathCounter = 1;

    /** @var EntityDao */
    private $dao;

    /** @var DefaultEntityBuilder */
    private $defaultEntityBuilder;

    /**
     * @param EntityDao $dao
     * @param IDefaultEntityBuilder $defaultEntityBuilder
     */
    public function __construct(EntityDao $dao, IDefaultEntityBuilder $defaultEntityBuilder)
    {
        $this->dao = $dao;
    }

    /**
     * Find entity in storage by id.
     * @param int $id
     * @return RankNick
     */
    public function find($id)
    {
        return $this->dao->find($id);
    }

    /**
     * Find all entities in storage by criteria with given order.
     * @param array $criteria
     * @param array $orderBy
     * @param int $limit
     * @param int $offset
     * @return RankNick[]
     */
    public function findBy(array $criteria, array $orderBy, $limit, $offset)
    {
        return $this->dao->findBy($criteria, $orderBy, $limit, $offset);
    }

    /**
     * Find one entity by criteria.
     * If there are more entities suitable for criteria, the first will be returned,
     * taking into account the orderBy parameters.
     * @param array $criteria
     * @param array $orderBy
     * @return RankNick
     */
    public function findOneBy(array $criteria, array $orderBy)
    {
        return $this->dao->findOneBy($criteria, $orderBy);
    }

    /**
     * Count entities in storage by given criteria.
     * @param array $criteria
     * @return int
     */
    public function countBy(array $criteria)
    {
        return $this->dao->countBy($criteria);
    }

    /**
     * Persist entity into storage.
     * @param RankNick $entity
     * @param bool $forceEntityIdOverAutoGenerated
     * @param bool $batchSize
     * @throws Exception
     */
    public function save(RankNick $entity, $forceEntityIdOverAutoGenerated = false, $batchSize = false)
    {
        $entityManager = $this->dao->getEntityManager();
        try {
            if ($forceEntityIdOverAutoGenerated) {
                $metadata = $this->dao->getClassMetadata(get_class($entity));
                $metadata->setIdGenerator(new AssignedGenerator());
                $metadata->setIdGeneratorType(ClassMetadata::GENERATOR_TYPE_NONE);
            }
            if ($batchSize !== false) {
                $entityManager->persist($entity);
                $this->bathCounter++;
                if (($this->bathCounter % $batchSize) == 0) {
                    $entityManager->flush();
                    $entityManager->clear();
                }
            } else {
                $this->dao->save($entity);
            }

        } catch (DuplicateEntryException $e) {
            throw new Exception("Can't save entity - unique constraint violation.", 10000, $e);
        }
    }

    /**
     * Finishes any waiting queries from bath processing
     */
    public function finishBathQueriesStillInFront()
    {
        $entityManager = $this->dao->getEntityManager();
        $entityManager->flush();
        $entityManager->clear();
        $this->bathCounter = 1;
    }

    /**
     * Remove entity from storage.
     * @param RankNick $entity
     */
    public function delete(RankNick $entity)
    {
        $this->dao->delete($entity);
    }

    /**
     * Create empty entity, does not store in database
     * @return RankNick
     */
    public function getEmptyEntityObject()
    {
        return $this->defaultEntityBuilder->createGame();
    }
}
